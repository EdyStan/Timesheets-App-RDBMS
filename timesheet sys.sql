-- 1) EMPLOYEES table: stores user info and JSON preferences.
CREATE TABLE employees (
  employee_id      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  first_name       VARCHAR2(50)        NOT NULL,
  last_name        VARCHAR2(50)        NOT NULL,
  email            VARCHAR2(100)       NOT NULL UNIQUE,
  prefs            JSON                -- semi-structured user preferences
)
-- Explanation: master list of employees; JSON prefs allows future extensibility.
/

-- Index on last_name for quick lookup
CREATE INDEX idx_employees_lastname ON employees(last_name);
 
-- 2) PROJECTS table: list of active/inactive projects.
CREATE TABLE projects (
  project_id       NUMBER               PRIMARY KEY,
  project_name     VARCHAR2(100)        NOT NULL UNIQUE,
  start_date       DATE                 NOT NULL,
  end_date         DATE,
  status           VARCHAR2(20) CHECK (status IN ('PLANNED','ACTIVE','ARCHIVED'))
)
-- Explanation: tracks projects; status enforces permitted values.
/

-- 3) TIMESHEET_ENTRIES table: daily log of hours per project.
CREATE TABLE timesheet_entries (
  entry_id         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  employee_id      NUMBER               NOT NULL,
  project_id       NUMBER               NOT NULL,
  entry_date       DATE                 NOT NULL,
  hours            NUMBER(4,2)          NOT NULL CHECK (hours >= 0 AND hours <= 24),  -- 4 digits in all, 2 decimal places.
  notes            CLOB  CHECK (notes IS JSON) , -- JSON-formatted notes
  CONSTRAINT fk_te_emp FOREIGN KEY (employee_id)
    REFERENCES employees(employee_id),
  CONSTRAINT fk_te_proj FOREIGN KEY (project_id)
    REFERENCES projects(project_id),
  CONSTRAINT uq_te UNIQUE (employee_id, entry_date, project_id)
)
-- Explanation: one row per employee/project/day; JSON notes for flexibility;
-- CHECK ensures valid hours; UNIQUE prevents duplicates.
/

-- Index on entry_date for fast date-range queries
CREATE INDEX idx_te_entry_date ON timesheet_entries(entry_date);

-- 4) VIEW: per-employee total hours over all time
CREATE OR REPLACE VIEW vw_employee_summary AS
SELECT
  e.employee_id,
  e.first_name || ' ' || e.last_name AS full_name,
  SUM(te.hours) AS total_hours
FROM employees e
JOIN timesheet_entries te
  ON e.employee_id = te.employee_id
GROUP BY e.employee_id, e.first_name, e.last_name
ORDER BY total_hours DESC;
-- Explanation: quick summary of total hours per employee.

-- 5) MATERIALIZED VIEW: total hours by project, refreshed on demand
CREATE MATERIALIZED VIEW mv_project_hours
BUILD IMMEDIATE
REFRESH COMPLETE ON DEMAND
AS
SELECT
  p.project_id,
  p.project_name,
  SUM(te.hours) AS project_hours
FROM projects p
LEFT JOIN timesheet_entries te
  ON p.project_id = te.project_id
GROUP BY p.project_id, p.project_name;
-- Explanation: pre-aggregates project hours for high-performance reporting.

-- ========================================================
-- 6) Sample Data Insertion & Use Case
-- ========================================================

-- Insert employees
INSERT INTO employees (first_name, last_name, email, prefs) VALUES
  ('Alice', 'Smith', 'alice.smith@company.com', JSON_OBJECT('daily_reminder' VALUE '08:00'));  
INSERT INTO employees (first_name, last_name, email, prefs) VALUES
  ('Bob',   'Jones', 'bob.jones@company.com',   JSON_OBJECT('daily_reminder' VALUE '09:00'));
-- Explanation: two sample employees with JSON prefs.

-- Insert projects
INSERT INTO projects (project_id, project_name, start_date, status) VALUES
  (1001, 'Website Redesign', DATE '2025-01-01', 'ACTIVE');
INSERT INTO projects (project_id, project_name, start_date, status) VALUES
  (1002, 'Mobile App',       DATE '2025-02-01', 'PLANNED');
-- Explanation: two projects; second has no end_date yet.

-- Insert timesheet entries
INSERT INTO timesheet_entries (employee_id, project_id, entry_date, hours, notes) VALUES
  (1, 1001, DATE '2025-06-09', 8, '{"tasks":["design","review"]}');
INSERT INTO timesheet_entries (employee_id, project_id, entry_date, hours, notes) VALUES
  (1, 1001, DATE '2025-06-10', 7.5, '{"tasks":["prototype"]}');
INSERT INTO timesheet_entries (employee_id, project_id, entry_date, hours, notes) VALUES
  (2, 1001, DATE '2025-06-10', 8, '{"tasks":["testing"]}');
-- Explanation: daily logs with JSON notes.

COMMIT;

-- ========================================================
-- 7) Use-Case Queries
-- ========================================================

-- a) Total hours per project (GROUP BY)
-- Shows each project and its total logged hours.
SELECT
  p.project_name,
  SUM(te.hours) AS total_hours
FROM projects p
JOIN timesheet_entries te
  ON p.project_id = te.project_id
GROUP BY p.project_name
ORDER BY total_hours DESC;
-- Decision: Manager sees 'Website Redesign' has X hours and can reallocate resources.

-- b) List all employees, even those with no entries (LEFT JOIN)
-- Helps identify people who havenâ€™t logged any time.
SELECT
  e.employee_id,
  e.first_name || ' ' || e.last_name AS name,
  NVL(te.hours,0) AS hours_logged
FROM employees e
LEFT JOIN timesheet_entries te
  ON e.employee_id = te.employee_id
WHERE te.entry_date = DATE '2025-06-10'
ORDER BY e.last_name;
-- Decision: Admin can remind those with zero hours to fill in their timesheets.

-- c) Weekly ranking of employee total hours (ANALYTIC: RANK)
-- Finds the top 5 contributors for the week starting 2025-06-09.
SELECT *
FROM (
  SELECT
    te.employee_id,
    SUM(te.hours) AS week_hours,
    RANK() OVER (ORDER BY SUM(te.hours) DESC) AS hrs_rank
  FROM timesheet_entries te
  WHERE te.entry_date BETWEEN DATE '2025-06-09' AND DATE '2025-06-15'
  GROUP BY te.employee_id
)
WHERE hrs_rank <= 5;
-- Decision: Recognize top performers or flag potential overtime.

